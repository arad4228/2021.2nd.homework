과제 #03

1. Shallow assignment. a변수의 구조체 값들을 b라는 변수의 메모리 공간에 bit by bit 형태로 복사함. a.data가 가리키는 공간과 b.data가 가리키는 공간이 같으므로, a.data가 free되면 b.data는 dangling pointer (reference)가 됨.
이 문제를 해결하는 방법은 

A b = a;
b.data = (char*) malloc(100); // b.data에 새로운 공간을 할당
memcpy(b.data, a.data, 100);  // a.data에 있는 데이터를 b.data가 가리키는 공간에 복사

같은 형태로 deep assignment와 유사한 효과를 만들어주어야 함. 

2. 앨리어스가 아님. x변수 선언은 언어에 따라서 실제 할당할 수 있는 메모리 공간의 크기를 정확하게 알 수 없어 컴파일 오류가 발생할 수 있음. 4번째 줄에 있는 cell의 정의(definition)가 나타난 후에야 x 변수가 사용하는 메모리 공간의 크기를 파악할 수 있음. 다만 이 경우에 x 변수를 선언하는 과정에서 컴파일 오류가 발생하지 않는다고 가정하면, 우리가 배운 내용으로 보면 x, y는 다르다고 보는 것이 맞음

과제 #04
1. alignment를 짝수에 맞춘다면 record(구조체는) 
s : 0-1
c : 2-3 // alignment를 맞추기 위해 1바이트를 추가
t : 4-5
d : 6-7 // alignment를 맞추기 위해 1바이트를 추가
r : 8-15
i : 16-19

20바이트를 사용함

배열이 10개이고, 배열의 요소 역시 작수 바이트에 alignment를 맞추게 되므로, 이 경우에는 큰 문제 없음.
따라서 20 * 10 = 200바이트 사용

2. 구조체를 assign하는 것은 메모리에 있는 내용을 bit by bit 형태로 복사하면 됨. alignment를 맞추기 위해서 추가된 메모리 공간이 복사되어도 상관없음. 비교하는 것도 bit by bit로 서로 비교해서 같은지 확인하면 된다고 할 수 있지만, 여기서 문제가 되는 부분이 앞에서 보였던 것처럼 alignment를 위해서 덧붙여진 메모리 공간들임. 이렇게 덧붙여진 메모리 공간에 있는 값들은 원래 어떤 값들이 있었는지 모르기 때문에, 두 개 구조체의 값이 모두 같다고 하더라도 다르다고 나올 수 있음. 덧붙여진 공간에 있던 쓰레기값(garbage value)이 어떤 값인지 모르고, 두 메모리 공간에 있는 garbage value들이 같은지 모르기 때문인데, 이런 문제를 해결하려면, 결국 값을 저장할 때나 구조체를 처음에 생성할 때 구조체의 모든 메모리 공간(쓰이지 앟는 덧붙여진 공간을 포함해서)을 초기화 시킨는 것이 필요함. 그런데 보통은 그렇게까지 하지 않기 때문에 구현이 더 어려움. 